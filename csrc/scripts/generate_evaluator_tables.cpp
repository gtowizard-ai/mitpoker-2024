#include "../src/hand_category.h"

#include <algorithm>
#include <array>
#include <cstdint>
#include <iostream>
#include <limits>
#include <map>
#include <set>
#include <tuple>
#include <type_traits>
#include <utility>
#include <vector>

using namespace pokerbot;

constexpr unsigned num_ranks = 13;

using rank_key_t = int32_t;

/// Bases for each rank.
/// @example A set of 5 cards of ranks {1, 1, 2, 3, 5} corresponds to the value `17629`, which is
/// equal to `2049 * 2 + 3076 + 4111 + 6344`. Every set of <= 8 cards should have a unique value.
/// These bases are generated by `scripts/generate_rank_bases.cpp` (`first_basis = 1024`).
constexpr std::array<rank_key_t, num_ranks> rank_bases = {
    1024, 2049, 3076, 4111, 5175, 6344, 18312, 51344, 195385, 637219, 1584497, 4970346, 11991192};

/// Returns the bit width of `x`.
int bit_width(unsigned x) {
  return 32 - __builtin_clz(x);
}

/// Returns whether `x` has more than one bit set.
bool has_multiple_bits(unsigned x) {
  return (x & (x - 1)) != 0;
}

/// See: https://graphics.stanford.edu/~seander/bithacks.html#NextBitPermutation
unsigned next_bit_combination(unsigned mask) {
  const unsigned t = mask | (mask - 1);
  return (t + 1) | (((~t & (t + 1)) - 1) >> (__builtin_ctz(mask) + 1));
}

/// Keeps `n` most significant bits of `x`.
unsigned keep_significant_n_bits(unsigned x, unsigned n) {
  unsigned result = 0;
  for (unsigned i = 0; x != 0 && i < n; ++i) {
    const unsigned bit = 1 << (bit_width(x) - 1);
    result |= bit;
    x ^= bit;
  }
  return result;
}

/// Keeps the most significant bit of a made straight, or returns 0 if no straight is made.
unsigned find_straight(unsigned rank_bitset) {
  constexpr unsigned wheel = 0b1'0000'0000'1111;
  const unsigned shifted_bitand = rank_bitset & (rank_bitset << 1) & (rank_bitset << 2) &
                                  (rank_bitset << 3) & (rank_bitset << 4);
  if (shifted_bitand != 0) {
    return keep_significant_n_bits(shifted_bitand, 1);
  } else if ((rank_bitset & wheel) == wheel) {
    return 0b1000;
  } else {
    return 0;
  }
}

/// Returns a 32-bit value representing the strength of a hand. Higher value is better.
unsigned make_strength_value(HandCategory category, unsigned rank, unsigned kicker) {
  return (static_cast<unsigned>(category) << 26) | (rank << 13) | kicker;
}

/// Returns a hand category from a strength value.
std::underlying_type_t<HandCategory> hand_category(unsigned strength) {
  return strength >> 26;
}

/// Returns the strength of a non-flush hand, given the number of cards of each rank.
unsigned evaluate_nonflush(const std::array<uint8_t, num_ranks>& rank_counts) {
  unsigned rank_bitset = 0;
  std::array<unsigned, 5> rank_bitset_of_count = {};

  for (unsigned rank = 0; rank < num_ranks; ++rank) {
    if (rank_counts[rank] != 0) {
      rank_bitset |= 1 << rank;
      rank_bitset_of_count[rank_counts[rank]] |= 1 << rank;
    }
  }

  if (rank_bitset_of_count[4] != 0) {
    // Four of a kind
    unsigned quad = keep_significant_n_bits(rank_bitset_of_count[4], 1);
    unsigned kicker = keep_significant_n_bits(rank_bitset ^ quad, 1);
    return make_strength_value(HandCategory::FourOfAKind, quad, kicker);
  } else if (has_multiple_bits(rank_bitset_of_count[3])) {
    // Full house
    unsigned triplet = keep_significant_n_bits(rank_bitset_of_count[3], 1);
    unsigned triplet_other = rank_bitset_of_count[3] ^ triplet;
    unsigned pair = keep_significant_n_bits(triplet_other | rank_bitset_of_count[2], 1);
    return make_strength_value(HandCategory::FullHouse, triplet, pair);
  } else if (rank_bitset_of_count[3] != 0 && rank_bitset_of_count[2] != 0) {
    // Full house
    unsigned pair = keep_significant_n_bits(rank_bitset_of_count[2], 1);
    return make_strength_value(HandCategory::FullHouse, rank_bitset_of_count[3], pair);
  } else if (unsigned straight = find_straight(rank_bitset); straight != 0) {
    // Straight
    return make_strength_value(HandCategory::Straight, straight, 0);
  } else if (rank_bitset_of_count[3] != 0) {
    // Three of a kind
    unsigned kicker = keep_significant_n_bits(rank_bitset_of_count[1], 2);
    return make_strength_value(HandCategory::ThreeOfAKind, rank_bitset_of_count[3], kicker);
  } else if (has_multiple_bits(rank_bitset_of_count[2])) {
    // Two pair
    unsigned pairs = keep_significant_n_bits(rank_bitset_of_count[2], 2);
    unsigned kicker = keep_significant_n_bits(rank_bitset ^ pairs, 1);
    return make_strength_value(HandCategory::TwoPair, pairs, kicker);
  } else if (rank_bitset_of_count[2] != 0) {
    // Pair
    unsigned kicker = keep_significant_n_bits(rank_bitset_of_count[1], 3);
    return make_strength_value(HandCategory::Pair, rank_bitset_of_count[2], kicker);
  } else {
    // High card
    unsigned rank = keep_significant_n_bits(rank_bitset, 5);
    return make_strength_value(HandCategory::HighCard, rank, 0);
  }
}

/// Returns the strength of a flush hand, given the bitset of ranks.
unsigned evaluate_flush(unsigned rank_bitset) {
  if (unsigned straight = find_straight(rank_bitset); straight != 0) {
    // Straight flush
    return make_strength_value(HandCategory::StraightFlush, straight, 0);
  } else {
    // Flush
    unsigned rank = keep_significant_n_bits(rank_bitset, 5);
    return make_strength_value(HandCategory::Flush, rank, 0);
  }
}

/// Recursive function that enumerates all possible non-flush hands and stores their strength.
void enumerate_nonflush_hands(std::array<uint8_t, num_ranks>& rank_counts,
                              std::map<rank_key_t, unsigned>& strength_map,
                              std::set<unsigned>& seen_strengths, unsigned max_num_cards,
                              unsigned current_rank = 0, unsigned current_num_cards = 0,
                              rank_key_t rank_key = 0) {
  // termination case
  if (current_rank == num_ranks) {
    if (strength_map.count(rank_key)) {
      std::cerr << "fatal error: `rank_bases` is not well-defined\n";
      std::cerr << "duplicate rank key: " << rank_key << std::endl;
      std::exit(EXIT_FAILURE);
    }

    const auto strength = evaluate_nonflush(rank_counts);
    strength_map.emplace(rank_key, strength);
    seen_strengths.insert(strength);
    return;
  }

  // recursive case
  const unsigned max_count = std::min(max_num_cards - current_num_cards, 4u);
  for (unsigned count = 0; count <= max_count; ++count) {
    rank_counts[current_rank] = count;
    enumerate_nonflush_hands(rank_counts, strength_map, seen_strengths, max_num_cards,
                             current_rank + 1, current_num_cards + count,
                             rank_key + rank_bases[current_rank] * count);
  }
}

/// Enumerates all possible flush hands and stores their strength.
void enumerate_flush_hands(std::map<unsigned, unsigned>& strength_map,
                           std::set<unsigned>& seen_strengths, unsigned max_num_cards) {
  constexpr unsigned end = 1 << num_ranks;
  for (unsigned num_cards = 5; num_cards <= max_num_cards; ++num_cards) {
    for (unsigned rank_bitset = (1 << num_cards) - 1; rank_bitset < end;
         rank_bitset = next_bit_combination(rank_bitset)) {
      const auto strength = evaluate_flush(rank_bitset);
      strength_map.emplace(rank_bitset, strength);
      seen_strengths.insert(strength);
    }
  }
}

/// Creates a strength conversion map from `unsigned` to `strength_t`.
std::map<unsigned, strength_t> create_strength_map(const std::set<unsigned>& seen_strengths) {
  std::map<unsigned, strength_t> result;

  strength_t current_category = 0;
  strength_t current_rank = 0;

  for (auto strength : seen_strengths) {
    if (auto category = hand_category(strength); category != current_category) {
      current_category = category;
      current_rank = 0;
    }

    if (current_rank >= (1 << detail::HAND_CATEGORY_SHIFT)) {
      std::cerr << "fatal error: `HAND_CATEGORY_SHIFT` is too small" << std::endl;
      std::exit(EXIT_FAILURE);
    }

    result.emplace(strength, (current_category << detail::HAND_CATEGORY_SHIFT) | current_rank++);
  }

  return result;
}

/// Generates an offset table for the hand evaluator by the first-fit-decreasing heuristic.
/// @details This function tries to find an efficient table for the following perfect hash:
/// ```
///   hash_value = rank_key + RANK_KEY_OFFSET_TABLE[rank_key >> RANK_KEY_OFFSET_SHIFT];
/// ```
/// Where `rank_key` is a 32-bit integer representing the combination of card ranks in a hand, and
/// its domain is sparse. `hash_value` is also a 32-bit integer, but its range is dense. The goal is
/// to find `RANK_KEY_OFFSET_TABLE` that minimizes the possible maximum value of `hash_value`, while
/// keeping the table size small.
/// @remark Reference: Z. J. Czech, G. Havas, and B. S. Majewski. "Perfect hashing". Theoretical
/// Computer Science, 1997. (Section 5.2)
std::tuple<std::vector<rank_key_t>, int, int> generate_offset_table(
    const std::map<rank_key_t, unsigned>& strength_map) {
  // store the rank keys as a vector
  std::vector<rank_key_t> rank_keys;
  rank_keys.reserve(strength_map.size());
  for (const auto& [key, _] : strength_map) {
    rank_keys.push_back(key);
  }

  const auto max_rank_key = rank_keys.back();
  const int half_log2 = (bit_width(max_rank_key) - 1) / 2;

  int best_cost = std::numeric_limits<int>::max();
  std::vector<rank_key_t> best_offset_table;
  int best_shift = -1;
  int best_table_size = -1;
  bool prune[2] = {false, false};

  for (int zigzag = 0; !(prune[0] && prune[1]); ++zigzag) {
    const int i = (zigzag >> 1) ^ -(zigzag & 1);  // 0, -1, 1, -2, 2, ...
    if (prune[i > 0] || i < -half_log2) {
      continue;
    }

    const int shift = half_log2 + i;
    const int mask = (1 << shift) - 1;
    const int num_buckets = (max_rank_key + mask) >> shift;

    std::vector<std::tuple<unsigned, unsigned, int>> buckets;
    buckets.reserve(num_buckets);

    unsigned index = 0;
    for (int j = 0; j < num_buckets; ++j) {
      const unsigned start = index;
      while (index < rank_keys.size() && (rank_keys[index] >> shift) == j) {
        ++index;
      }
      buckets.emplace_back(start, index, j);
    }

    // sort the buckets in descending order of size
    std::stable_sort(buckets.begin(), buckets.end(), [](auto&& lhs, auto&& rhs) {
      return std::get<1>(lhs) - std::get<0>(lhs) > std::get<1>(rhs) - std::get<0>(rhs);
    });

    int first_empty = 0;
    int table_size = 0;
    std::vector<rank_key_t> offset_table(num_buckets);
    std::vector<bool> filled(num_buckets << shift);

    for (const auto& [start, end, index] : buckets) {
      if (start == end) {
        break;
      }

      // find the leftmost fitting position
      int pos = first_empty;
      do {
        if (std::all_of(rank_keys.cbegin() + start, rank_keys.cbegin() + end,
                        [&](auto key) { return !filled[pos + (key & mask)]; })) {
          break;
        }
      } while (++pos);

      offset_table[index] = pos - (index << shift);
      std::for_each(rank_keys.cbegin() + start, rank_keys.cbegin() + end,
                    [&](auto key) { filled[pos + (key & mask)] = true; });

      // update `first_empty` and `table_size`
      while (filled[first_empty]) {
        ++first_empty;
      }
      table_size = std::max(table_size, pos + (rank_keys[end - 1] & mask) + 1);
    }

    // calculate the cost
    const int cost = num_buckets * 4 + table_size * 2;  // 4 bytes per offset, 2 bytes per strength
    std::cerr << "info: generate_offset_table: shift = " << shift << ", cost = " << cost << " ("
              << num_buckets << " * 4 + " << table_size << " * 2)" << std::endl;

    if (cost < best_cost) {
      best_cost = cost;
      best_offset_table = std::move(offset_table);
      best_shift = shift;
      best_table_size = table_size;
    } else {
      prune[i > 0] = true;
    }
  }

  return {best_offset_table, best_shift, best_table_size};
}

int main() {
  // [Usage]
  // ./build/scripts/generate_evaluation_tables > csrc/src/poker_hand_tables.h

  constexpr unsigned num_cards = 8;

  std::set<unsigned> seen_strengths;
  std::map<rank_key_t, unsigned> nonflush_strength_map;
  std::map<unsigned, unsigned> flush_strength_map;

  std::array<uint8_t, num_ranks> rank_counts = {};
  enumerate_flush_hands(flush_strength_map, seen_strengths, num_cards);
  enumerate_nonflush_hands(rank_counts, nonflush_strength_map, seen_strengths, num_cards);

  const auto strength_map = create_strength_map(seen_strengths);
  const auto [offset_table, shift, table_size] = generate_offset_table(nonflush_strength_map);

  std::vector<strength_t> flush_table((((1 << num_cards) - 1) << (num_ranks - num_cards)) + 1);
  for (const auto& [rank_bitset, strength] : flush_strength_map) {
    flush_table[rank_bitset] = strength_map.at(strength);
  }

  std::vector<strength_t> nonflush_table(table_size);
  for (const auto& [rank_key, strength] : nonflush_strength_map) {
    const auto offset = offset_table[rank_key >> shift];
    nonflush_table[rank_key + offset] = strength_map.lower_bound(strength)->second;
  }

  // generate code
  std::cout << "// This file is generated by scripts/generate_evaluator_tables.cpp\n\n";
  std::cout << "#pragma once\n\n";
  std::cout << "#include \"hand_category.h\"\n\n";
  std::cout << "#include <cstdint>\n\n";
  std::cout << "namespace pokerbot::detail {\n\n";
  std::cout << "using rank_key_t = int32_t;\n\n";
  std::cout << "inline constexpr unsigned RANK_KEY_OFFSET_SHIFT = " << shift << ";\n\n";
  std::cout << "inline constexpr rank_key_t RANK_BASES[" << num_ranks << "] = { ";
  std::for_each(rank_bases.cbegin(), rank_bases.cend(),
                [](auto basis) { std::cout << basis << ", "; });
  std::cout << "};\n\n";
  std::cout << "inline const rank_key_t RANK_KEY_OFFSET_TABLE[" << offset_table.size() << "] = { ";
  std::for_each(offset_table.cbegin(), offset_table.cend(),
                [](auto offset) { std::cout << offset << ", "; });
  std::cout << "};\n\n";
  std::cout << "inline const strength_t FLUSH_LOOKUP_TABLE[" << flush_table.size() << "] = { ";
  std::for_each(flush_table.cbegin(), flush_table.cend(),
                [](auto strength) { std::cout << strength << ", "; });
  std::cout << "};\n\n";
  std::cout << "inline const strength_t NONFLUSH_LOOKUP_TABLE[" << nonflush_table.size()
            << "] = { ";
  std::for_each(nonflush_table.cbegin(), nonflush_table.cend(),
                [](auto strength) { std::cout << strength << ", "; });
  std::cout << "};\n\n";
  std::cout << "}  // namespace pokerbot::detail\n";
}
